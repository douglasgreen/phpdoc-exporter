<?php

declare(strict_types=1);

namespace DouglasGreen\PhpDocExporter\Core;

use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocNode;
use PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode;

/**
 * Generates hierarchical Markdown documentation from extracted PHPDoc data.
 *
 * Transforms parsed PHPDoc structures into GitHub-compatible Markdown
 * with proper headings, code blocks, and cross-references.
 *
 * @package DouglasGreen\PhpDocExporter\Core
 *
 * @api
 *
 * @since 1.0.0
 */
final class MarkdownGenerator
{
    private readonly Validator $validator;

    /** @var list<array{level: string, rule: string, element: string, message: string, file: string}> */
    private array $allWarnings = [];

    public function __construct()
    {
        $this->validator = new Validator();
    }

    /**
     * Generates a complete Markdown document from extracted documentation.
     *
     * @param list<array{file: string, elements: list<array>}> $documentation Extracted documentation data
     * @param string $projectName Project name for the document
     *
     * @return array{markdown: string, warnings: list<array{level: string, rule: string, element: string, message: string}>}
     */
    public function generate(array $documentation, string $projectName = 'PHP Documentation'): array
    {
        $this->allWarnings = [];

        $lines = [
            '# ' . $projectName,
            '',
            '> Generated by phpdoc-exporter on ' . date('Y-m-d H:i:s'),
            '',
            '---',
            '',
        ];

        // Group by file for organization
        $byFile = $this->groupByFile($documentation);

        foreach ($byFile as $filePath => $elements) {
            $lines = [...$lines, ...$this->generateFileSection($filePath, $elements)];
        }

        // Print warnings to stderr if any
        if ($this->allWarnings !== []) {
            $this->printWarningsToStderr();
        }

        $markdown = implode("\n", $lines);

        return [
            'markdown' => $markdown,
            'warnings' => $this->allWarnings,
        ];
    }

    /**
     * Groups documentation elements by file path.
     *
     * @param list<array{file: string, elements: list<array>}> $documentation Raw documentation
     *
     * @return array<string, list<array>>
     */
    private function groupByFile(array $documentation): array
    {
        $grouped = [];

        foreach ($documentation as $fileDoc) {
            $filePath = $fileDoc['file'];
            $grouped[$filePath] = $fileDoc['elements'];
        }

        return $grouped;
    }

    /**
     * Generates Markdown section for a single file.
     *
     * @param string $filePath File path
     * @param list<array{type: string, name: string, namespace: string|null, startLine: int, endLine: int, doc: PhpDocNode|null, docText: string|null}> $elements Documentation elements
     *
     * @return list<string> Markdown lines
     */
    private function generateFileSection(string $filePath, array $elements): array
    {
        $relativePath = $this->getRelativePath($filePath);

        $lines = [
            '## File: `' . $relativePath . '`',
            '',
        ];

        // Separate file-level docblock from other elements
        $fileElements = array_values(array_filter($elements, fn (array $e): bool => $e['type'] === 'file'));
        $otherElements = array_values(array_filter($elements, fn (array $e): bool => $e['type'] !== 'file'));

        // Output file-level docblock first
        foreach ($fileElements as $fileElement) {
            $lines = [...$lines, ...$this->generateElementSection($fileElement, $filePath)];
        }

        // Group elements by type for hierarchical output
        $classes = [];
        $interfaces = [];
        $traits = [];
        $functions = [];
        $properties = [];

        foreach ($otherElements as $element) {
            $type = $element['type'];

            match ($type) {
                'class' => $classes[] = $element,
                'interface' => $interfaces[] = $element,
                'trait' => $traits[] = $element,
                'function' => $functions[] = $element,
                'property' => $properties[] = $element,
                'method' => null, // Methods handled within class context
                default => null,
            };
        }

        // Output in standard order
        foreach ($interfaces as $interface) {
            $lines = [...$lines, ...$this->generateElementSection($interface, $filePath)];
        }

        foreach ($traits as $trait) {
            $lines = [...$lines, ...$this->generateElementSection($trait, $filePath)];
        }

        foreach ($classes as $class) {
            $lines = [...$lines, ...$this->generateElementSection($class, $filePath)];
            // Add methods for this class
            $className = $class['name'];
            $classMethods = array_values(array_filter(
                $otherElements,
                fn (array $e): bool => $e['type'] === 'method' && str_starts_with((string) $e['name'], $className . '::'),
            ));
            foreach ($classMethods as $method) {
                $lines = [...$lines, ...$this->generateElementSection($method, $filePath, indent: true)];
            }
        }

        foreach ($functions as $function) {
            $lines = [...$lines, ...$this->generateElementSection($function, $filePath)];
        }

        foreach ($properties as $property) {
            $lines = [...$lines, ...$this->generateElementSection($property, $filePath)];
        }

        $lines[] = '';

        return $lines;
    }

    /**
     * Generates Markdown section for a single element.
     *
     * @param array{type: string, name: string, namespace: string|null, startLine: int, endLine: int, doc: PhpDocNode|null, docText: string|null} $element Element data
     * @param string $filePath File path for validation
     * @param bool $indent Whether to indent (for class members)
     *
     * @return list<string> Markdown lines
     */
    private function generateElementSection(array $element, string $filePath, bool $indent = false): array
    {
        $prefix = $indent ? '    ' : '';
        $headingLevel = $element['type'] === 'file' ? '###' : ($indent ? '####' : '###');

        $name = $element['name'];
        $type = $element['type'];
        $doc = $element['doc'];
        $docText = $element['docText'];
        $namespace = $element['namespace'];
        $startLine = $element['startLine'];

        // Validate and collect warnings
        $warnings = $this->validator->validate($doc, $type, $name, $filePath, $startLine);
        foreach ($warnings as $warning) {
            $warning['file'] = $this->getRelativePath($filePath);
            $this->allWarnings[] = $warning;
        }

        $displayType = ucfirst((string) $type);
        $displayName = $type === 'file' ? 'Script/File' : $name;

        $lines = [
            $prefix . $headingLevel . ' ' . $displayType . ': `' . $displayName . '`',
            '',
        ];

        if ($namespace !== null) {
            $lines[] = $prefix . '**Namespace:** `' . $namespace . '`';
            $lines[] = '';
        }

        if ($docText !== null) {
            $lines[] = $prefix . '```php';
            $lines[] = $prefix . trim($docText);
            $lines[] = $prefix . '```';
            $lines[] = '';

            // Extract and format specific tags
            if ($doc instanceof PhpDocNode) {
                $lines = [...$lines, ...$this->generateTags($doc, $prefix)];
            }
        } else {
            $lines[] = $prefix . '*No documentation available.*';
            $lines[] = '';
        }

        $lines[] = $prefix . '---';
        $lines[] = '';

        return $lines;
    }

    /**
     * Generates formatted tag sections from a PHPDoc node.
     *
     * @param PhpDocNode $doc Parsed PHPDoc node
     * @param string $prefix Line prefix
     *
     * @return list<string> Markdown lines
     */
    private function generateTags(PhpDocNode $doc, string $prefix): array
    {
        $lines = [];
        $tagGroups = $this->extractTags($doc);

        if (isset($tagGroups['param']) && $tagGroups['param'] !== []) {
            $lines[] = $prefix . '**Parameters:**';
            $lines[] = '';
            foreach ($tagGroups['param'] as $tag) {
                $lines[] = $prefix . $this->formatTag($tag);
            }

            $lines[] = '';
        }

        if (isset($tagGroups['return']) && $tagGroups['return'] !== []) {
            $lines[] = $prefix . '**Returns:**';
            $lines[] = '';
            foreach ($tagGroups['return'] as $tag) {
                $lines[] = $prefix . $this->formatTag($tag);
            }

            $lines[] = '';
        }

        if (isset($tagGroups['throws']) && $tagGroups['throws'] !== []) {
            $lines[] = $prefix . '**Throws:**';
            $lines[] = '';
            foreach ($tagGroups['throws'] as $tag) {
                $lines[] = $prefix . $this->formatTag($tag);
            }

            $lines[] = '';
        }

        if (isset($tagGroups['see']) && $tagGroups['see'] !== []) {
            $lines[] = $prefix . '**See Also:**';
            $lines[] = '';
            foreach ($tagGroups['see'] as $tag) {
                $lines[] = $prefix . $this->formatTag($tag);
            }

            $lines[] = '';
        }

        if (isset($tagGroups['deprecated']) && $tagGroups['deprecated'] !== []) {
            $lines[] = $prefix . '**⚠️ Deprecated:**';
            $lines[] = '';
            foreach ($tagGroups['deprecated'] as $tag) {
                $lines[] = $prefix . $this->formatTag($tag);
            }

            $lines[] = '';
        }

        return $lines;
    }

    /**
     * Extracts and groups tags from a PHPDoc node.
     *
     * @param PhpDocNode $doc Parsed PHPDoc node
     *
     * @return array{param: list<PhpDocTagNode>, return: list<PhpDocTagNode>, throws: list<PhpDocTagNode>, see: list<PhpDocTagNode>, deprecated: list<PhpDocTagNode>}
     */
    private function extractTags(PhpDocNode $doc): array
    {
        $groups = [
            'param' => [],
            'return' => [],
            'throws' => [],
            'see' => [],
            'deprecated' => [],
        ];

        foreach ($doc->children as $child) {
            if ($child instanceof PhpDocTagNode) {
                $tagName = ltrim($child->name, '@');
                $baseName = strtok($tagName, '-');

                if ($baseName !== false && array_key_exists($baseName, $groups)) {
                    $groups[$baseName][] = $child;
                }
            }
        }

        return $groups;
    }

    /**
     * Formats a single PHPDoc tag as Markdown.
     *
     * @param PhpDocTagNode $tag Tag node to format
     */
    private function formatTag(PhpDocTagNode $tag): string
    {
        return '- `' . ltrim($tag->name, '@') . '`: ' . trim((string) $tag->value);
    }

    /**
     * Prints warnings to stderr.
     */
    private function printWarningsToStderr(): void
    {
        $stderr = fopen('php://stderr', 'w');
        if ($stderr === false) {
            return;
        }

        fwrite($stderr, "PHPDoc Standards Violations:\n");
        fwrite($stderr, "The following violations of `phpdoc.md` standards were detected:\n\n");

        $mustWarnings = array_values(array_filter(
            $this->allWarnings,
            fn (array $w): bool => $w['level'] === 'MUST',
        ));
        $shouldWarnings = array_values(array_filter(
            $this->allWarnings,
            fn (array $w): bool => $w['level'] === 'SHOULD',
        ));

        if ($mustWarnings !== []) {
            fwrite($stderr, "MUST Violations (Critical):\n");
            foreach ($mustWarnings as $warning) {
                fwrite($stderr, sprintf(
                    "  - [%s] %s (%s)\n",
                    $warning['rule'],
                    $warning['message'],
                    $warning['file'],
                ));
            }

            fwrite($stderr, "\n");
        }

        if ($shouldWarnings !== []) {
            fwrite($stderr, "SHOULD Improvements:\n");
            foreach ($shouldWarnings as $warning) {
                fwrite($stderr, sprintf(
                    "  - [%s] %s (%s)\n",
                    $warning['rule'],
                    $warning['message'],
                    $warning['file'],
                ));
            }

            fwrite($stderr, "\n");
        }

        fclose($stderr);
    }

    /**
     * Converts an absolute path to relative for display.
     *
     * @param string $filePath Absolute file path
     */
    private function getRelativePath(string $filePath): string
    {
        $cwd = getcwd();
        if ($cwd === false) {
            return $filePath;
        }

        $normalizedPath = str_replace('\\', '/', $filePath);
        $normalizedCwd = str_replace('\\', '/', $cwd);

        if (str_starts_with($normalizedPath, $normalizedCwd)) {
            return ltrim(substr($normalizedPath, strlen($normalizedCwd)), '/');
        }

        return $filePath;
    }
}
